[{"categories":["Project"],"content":"Chuyển file Excel thành file CSV sử dụng pandas Bạn có thể dễ dàng đọc một file Excel bằng python sử dụng thư viện pandas. Pandas là bộ công cụ phân tích và xử lý dữ liệu rất mạnh mẽ, nó được sử dụng rộng rãi trong cả nghiên cứu lẫn phát triển các ứng dụng về khoa học dữ liệu. Để đạt được mục tiêu ở đầu bài, chúng ta sẽ sử dụng các hàm xử lý có trong pandas. Đầu tiên, hãy cài đặt thư viện pandas, bạn nên cài pandas version 1.2.0 trở lên để tránh một số lỗi không cần thiết, máy mình sử dụng pandas 1.0 đã gặp một số lỗi, update lên thì ok: pip install pandas==1.2.0\r Để đọc một file excel ta sử dụng hàm read_excel, dưới đây là đoạn mã mẫu đọc một file excel bất kỳ: import pandas as pd\rdf = pd.read_excel(r'path_to_file/file_name.xlsx')\rprint(df) # in ra những gì có trong file excel\r Để chuyển một file excel thành một file csv ta sử dụng hàm to_csv: import pandas as pd\rread_file = pd.read_excel (r'path_to_file/file_name.xlsx')\rread_file.to_csv (r'path_to_file/file_name_new.csv', index = None, header=True)\r Tool chuyển đổi file excel sang file csv: Bằng những công cụ ở trên mình đã tạo ra một tool chuyển đổi file excel sang file csv, bạn có thể tham khảo đoạn mã dưới đây: import tkinter as tk from tkinter import filedialog from tkinter import messagebox import pandas as pd from PIL import ImageTk,Image root= tk.Tk() root.title=(\"Hai's tool conversion\") root.geometry(\"520x450+100+50\") root.resizable(False,False) title = tk.Label(root, text=\"Hai's Tool to Convert Excel files to CSV files\", font=(\"arial\", 18, \"bold\"), fg=\"#002431\", bg='yellow') title.place(x=0, y=10, relwidth=1) img = ImageTk.PhotoImage(file='convert.png') image_bg= tk.Label(root, image= img).place(x=0,y=50, relwidth=1) def getExcel (): global read_file import_file_path = filedialog.askopenfilename() read_file = pd.read_excel (import_file_path) import_button_excel = tk.Button(text=\"Import Excel File \", command=getExcel, bg='blue', fg='white', font=('consolas', 18, 'bold')) import_button_excel.place(x=100, y=250, width=300, height=40) def convertToCSV (): global read_file export_file_path = filedialog.asksaveasfilename(defaultextension='.csv') read_file.to_csv (export_file_path, index = None, header=True) convert_csv = tk.Button(text='Convert Excel to CSV', command=convertToCSV, bg='green', fg='white', font=('consolas', 18, 'bold')) convert_csv.place(x=100, y=310, width=300, height=40) exit_button = tk.Button(root, command=root.destroy, text=\"Exit\", font=(\"consolas\", 18, \"bold\"), bg=\"red\", fg=\"white\") exit_button.place(x=100, y= 370, width=300, height=40) root.mainloop()\r Thành quả: Bạn có thể tải tool về dùng thử bằng link sau: link giải nén, và chạy file gui1.exe ","date":"2021-03-21","objectID":"/vi/convert/:1:0","tags":["Project"],"title":"Chuyển file Excel thành file CSV sử dụng pandas","uri":"/vi/convert/"},{"categories":["AI knowledge"],"content":"Tổng Quan Artificial Neural Network ","date":"2020-12-25","objectID":"/vi/ann/:0:0","tags":["AI","Deep Learning","Machine Learning"],"title":"Tổng Quan Về Neural Network","uri":"/vi/ann/"},{"categories":["AI knowledge"],"content":"1. Neural Network là gì? Sự tương quan giữa Neural Network và não bộ của con người. Nguồn gốc của Neural Network là một thuật toán bắt chước não bộ, xuất phát từ việc nếu chúng ta muốn xây dựng các hệ thống learning. Và một câu hỏi được đặt ra là: “tại sao chúng ta lại không bắt chước bộ máy học tập tuyệt vời nhất là não bộ?\". Neural Networks đã được sử dụng rộng rãi từ những năm 1980 đến 1990, và vì nhiều lý do, nó ít phổ biến dần vào cuối những năm 90. Nhưng ngày này, neural networks đã có sự hồi sinh trở lại. Một trong những lý do cho sự hồi sinh này đó là neural networks là một thuật toán cần phải xử lý tính toán rất cồng kềnh, và nó chỉ có thể chạy được với những máy tính đủ nhanh như ngày nay và cũng bởi vì một số lý do kỹ thuật khác mà mình sẽ không đề cập ở đây. Đến nay, Neural networks đã trở thành một kỹ thuật tiên tiến cho nhiều ứng dụng. Bạn hãy thử nghĩ về việc bắt chước não bộ, não bộ của con người làm được rất nhiều điều tuyệt vời như: học cách để nhìn hình ảnh, học để nghe, học để xử lý cảm nhận tiếp xúc qua da, học để làm toán,… và rất nhiều việc tuyệt vời khác nữa. Rõ ràng nếu bạn muốn bắt chước não bộ thì bạn phải viết rất nhiều phần khác nhau của phần mềm để bắt chước các chức năng tuyệt vời đó. Nhưng liệu có phải rằng bộ não thực hiện các chức năng này giống với hàng ngàn chương trình khác nhau hay không? Hay thay vào đó, cách mà bộ não thực hiện chỉ giống như một thuật toán học tập duy nhất mà thôi? Và nếu có thì nó là gì và trông như thế nào? Nếu áp dụng và triển khai được nó trên máy tính, đó có thể sẽ là một bước tiến lớn cho việc thực hiện hoá trí tuệ nhân tạo - AI. ","date":"2020-12-25","objectID":"/vi/ann/:1:0","tags":["AI","Deep Learning","Machine Learning"],"title":"Tổng Quan Về Neural Network","uri":"/vi/ann/"},{"categories":["AI knowledge"],"content":"2. Biểu diễn mô hình Neural Network Neural Networks được xây dựng bằng cách mô phỏng các neuron hoặc mạng lưới neuron trong não bộ (neuron còn được gọi là tế bào não). Do đó, để dễ dàng hình dung sự tương quan này, chúng ta nên tìm hiểu sơ qua về neuron trong não bộ: Neuron cấu tạo gồm 3 thành phần chính: 1 thân chứa nhân ( Cell body hoặc Nucleus) 1 sợi trục dẫn truyền ly tâm (Axon) Các sợi nhánh (Dendrite) Sợi nhánh (Dendrite): nơi tiếp nhận xung động thần kinh để truyền đến neuron, bạn có thể xem nó như là input đầu vào dữ liệu. Thân chứa nhân(Cell Body): Đây là nơi tiếp nhận các xung động thần kinh, nó lấy các giá trị đầu vào thông qua sợi nhánh và thực hiện tính toán, sau đó gửi giá trị đầu ra thông qua sợi trục đến các neuron khác trong não bộ. Sợi trục (axon): Chính là nơi dẫn truyền những thông tin đầu ra hay output. ","date":"2020-12-25","objectID":"/vi/ann/:2:0","tags":["AI","Deep Learning","Machine Learning"],"title":"Tổng Quan Về Neural Network","uri":"/vi/ann/"},{"categories":["AI knowledge"],"content":"2.1 Mô hình Neural: Logistic Unit Trong một Neural Network mà ta triển khai trên máy tính, chúng ta thường sẽ sử dụng một mô hình rất đơn giản của neural, hãy xem hình dưới đây: Chúng ta sẽ mô hình hoá một neuron như là một đơn vị logistic. Vòng tròn lớn màu vàng tượng trưng như là thân của một neuron. x0, x1, x2, x3 chính là những giá trị input được đưa vào thân neuron bằng sợi nhánh, neuron sẽ thực hiện tính toán và cho ra một vài giá trị đầu ra thông qua sợi trục. h0(X) là hàm tính toán biểu diễn các giá trị output. Thỉnh thoảng ta sẽ gọi một neuron nhân tạo là hàm kích hoạt sigmoid (sigmoid activation) hoặc hàm kích hoặt logistic (logistic activation). Nó cũng còn một tên gọi khác là weights (w) . Ở trên là mô hình biểu diễn một neuron. vậy một mạng lưới neuron sẽ được biểu diễn như thế nào? ","date":"2020-12-25","objectID":"/vi/ann/:2:1","tags":["AI","Deep Learning","Machine Learning"],"title":"Tổng Quan Về Neural Network","uri":"/vi/ann/"},{"categories":["AI knowledge"],"content":"2.2 Neural Network Một Neural Network là một nhóm các neuron kết nối với nhau. Cùng xem ảnh dưới đây. Cụ thể ở đây, chúng ta có các giá trị đầu vào : x0, x1, x2, x3 (x0 có giá trị luôn bằng 1, ta có thể bỏ qua hoặc không tuỳ những ví dụ khác nhau) chúng lần lượt đi qua các neuron (hình tròn vàng), các neuron thực hiện tính toán và cho ra các giá trị output: w1,w2,w3..wi , các giá trị này tiếp tục đi qua các neuron tiếp theo, ta có thể dễ dàng thấy rằng, output của các neuron trước chính là input của các neuron sau, cho đến các neuron cuối sẽ cho ra một giá trị weight cuối cùng. Hãy cùng nhìn qua một số thuật ngữ sẽ được sử dụng sau này, Layer đầu tiên-Layer L1 được gọi là Input Layer bởi vì đây là nơi đưa vào các feature của chúng ta, x1, x2, x3. Layer cuối cùng-Layer L4 được gọi là Output layer vì nó là layer cho ra giá trị cuối cùng đã được tìm ra qua hàng loạt xử lý tính toán. Layer L2 và _Layer L3, những Layer nằm ở trung gian được gọi là hidden layer. Minh hoạ: ","date":"2020-12-25","objectID":"/vi/ann/:2:2","tags":["AI","Deep Learning","Machine Learning"],"title":"Tổng Quan Về Neural Network","uri":"/vi/ann/"},{"categories":["AI knowledge"],"content":"Tìm hiểu các thuật toán Object Detection, cụ thể với YOLO","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"Object Detection And YOLO ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:0:0","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"1. Giới thiệu về Object Detection và thuật toán ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:1:0","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"A. Object Detection là gì? Objetc Detection ( Phát hiện đối tượng) là một công nghệ máy tính liên quan đến lĩnh vực Computer Vision (thị giác máy tính) và Image Processing (Xử lý ảnh) nhằm phát hiện các đối tượng trong ảnh hoặc video kỹ thuật số (chẳng hạn như con người, đồ vật, động vật, thực vật, tòa nhà…). Object Detection có rất nhiều ứng dụng trong nhiều lĩnh vực Computer Vision như nhận diện khuôn mặt, Face ID của apple, hệ thống giám sát hàng loạt của trung quốc, … Dưới đây là cái nhìn tổng quát, để cho chúng ta có thể dễ dàng thấy được Object Detection đang nằm ở đâu trong những bài toán của Computer Vision. Image Classification: nhằm mục đích gán hình ảnh cho một trong số các danh mục khác nhau (ví dụ: ô tô, chó, mèo, người, v.v.), về cơ bản nó sẽ là câu trả lời của câu hỏi “Cái gì trong hình này?\"_. Một hình ảnh chỉ có một danh mục được gán cho nó. Object Localization: sau đó chúng ta định vị đối tượng của mình trong hình ảnh, vì vậy câu hỏi của chúng ta lúc này chuyển thành “Nó là gì và nó ở đâu?\" . Object Detection: cung cấp các công cụ để thực hiện việc tìm kiếm tất cả các đối tượng trong một hình ảnh và vẽ cái gọi là hộp giới hạn (Bounding Boxes) xung quanh chúng. Cũng có một số tình huống mà chúng ta muốn tìm ranh giới chính xác của các đối tượng của mình trong quá trình được gọi là phân đoạn cá thể (instance segmentation). ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:1:1","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"B. Các thuật toán của Object Detection Thuật toán Object Detection: Có 3 mô hình thuật toán chính về object detection mà chúng ta sẽ thường xuyên gặp phải: R-CNN và các biến thể: bao gồm R-CNN gốc, Fast R-CNN và Faster R-CNN Single Shot Detector (SSD) You only look one (YOLO) R-CNNs là một trong những mô hình thuật toán về phát hiện đối tượng đầu tiên dựa trên deep learning và là một hình mẫu về việc nhận diện qua 2 giai đoạn: Trong ấn phẩm đầu tiên của R-CNN,# Rich feature hierarchies for accurate object detection and semantic segmentation (tạm dịch: Hệ thống phân cấp tính năng các điểm đặc trưng để nhận đối tượng và phân đoạn ngữ nghĩa), (2013) Girshick et al. đã đề xuất một giải thuật tìm kiếm có chọn lọc nhằm tạo và trích xuất các vùng có khả năng chứa vật thể được bao bọc bởi các hộp giới hạn (gọi là boundingbox). Những vùng này sau đó được chuyển vào CNN để phân loại, cuối cùng cho chúng ta một trong những công cụ phát hiện đối tượng đầu tiên dựa trên học sâu (deep learning) . Vấn đề của phương pháp R-CNN bản gốc này là nó rất chậm, và nó chưa hoàn chỉnh. Fast R-CNN: Girshick và các cộng sự xuất bản bài báo thứ 2 vào năm 2015, có tựa đề Fast R-CNN . Thuật toán Fast R-CNN đã thực hiện những cải tiến đáng kể đối với R-CNN ban đầu, cụ thể là tăng độ chính xác và giảm thời gian thực hiện, tuy nhiên nó vẫn cần một tập hợp vùng đề xuất cho mỗi ảnh. Faster R-CNN: Cũng vào năm 2015, Grishick và các cộng sự tiếp tục công bố bài báo thứ 3 Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks (tạm dịch: R-CNN nhanh hơn: Hướng tới phát hiện đối tượng theo thời gian thực với mạng đề xuất khu vực). Đến lúc này, R-CNNs mới trở thành công cụ phát hiện đối tượng học sâu end-to-end thực sự bằng cách loại bỏ yêu cầu tìm kiếm có chọn lọc và thay vào đó dựa vào Mạng đề xuất khu vực (RPN). Đầu ra của RPN sau đó được chuyển vào thành phần R-CNN để phân loại và dán nhãn cuối cùng. R-CNNs có xu hướng rất chính xác, nhưng vấn đề lớn nhất với họ mạng R-CNN là tốc độ của chúng - chúng cực kỳ chậm, chỉ thu được 5 FPS trên GPU. SSD và YOLO: Để tăng tốc độ cho Object Detection, hai mô hình thuật toán mới đã ra đời là SSD và YOLO, cả hai đều sử dụng chung một chiến lược, đó là: phát hiện đối tượng trong 1 giai đoạn. Nói chung, thì cả YOLO và SSD có độ chính xác kém hơn nhưng nhanh hơn đáng kể. Trong những dự án thực tế, tốc độ đóng vai trò vô cùng quan trọng, nên SSD và YOLO dần chiếm ưu thế khi khoảng cách về độ chính xác giữa chúng và mô hình nhận diện hai giai đoạn của họ mạng R-CNN ngày càng được thu hẹp. Ở bài viết này, mình sẽ tập trung nói và viết về YOLO và để dành SSD cho bài viết khác, bởi theo như mình thấy hiện tại thì YOLO khá được ưa chuộng, và nó liên tục có những bản cập nhật mới từ khi ra đời vào năm 2015, hiện tại thì YOLOv5 đang làm mưa làm gió trên các diễn đàn về AI, ML, DL,… nhờ những đột phá mới, đặc biệt là tính dễ sử dụng. So với người anh em YOLO, SSD chỉ có 2 bản là SSD 300 và SSD 500, và chưa có bản update nào kể từ khi ra mắt. Thế nhưng SSD vẫn có những ưu điểm riêng và độ hiệu quả cũng vô cùng ấn tượng. Theo lẽ thường thì chúng ta sẽ phân tích ưu nhược điểm của YOLO sau khi nghiên cứu mô hình và cấu trúc mạng mà nó sử dụng, nhưng cá nhân mình thường nhìn vào kết quả và cách sử dụng trước sau đó mới tiến hành nghiên cứu chi tiết mô hình và cấu trúc của nó, điều này giúp mình rút ngắn kha khá thời gian khi làm một project. Việc học, làm như thế này cũng cho mình một cái nhìn tổng quát về những thứ mình đang làm, trước khi tìm hiểu sâu hơn vào một ví dụ cụ thể. Vậy ưu và nhược điểm của YOLO là gì và khi nào thì nên sử dụng nó? ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:1:2","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"2. YOLO - You Only Look Once Như đã nói ở trên YOLO là mô hình nhận diện một giai đoạn, nghĩa là coi việc phát hiện đối tượng như một bài toán hồi quy, lấy một hình ảnh đầu vào nhất định và đồng thời học tọa độ hộp giới hạn cùng xác suất nhãn lớp tương ứng. ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:2:0","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"A. Ưu điểm: Những ưu điểm chính của YOLO: Nhanh chóng và chính xác Gọn nhẹ Mã nguồn mở (Open source) Bạn có thể dễ dàng đánh đổi giữa tốc độ và độ chính xác chỉ bằng cách thay đổi kích thước của mô hình, không cần đào tạo lại! ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:2:1","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"B. Nhược điểm: Những nhược điểm chính của YOLO: Nhận diện chưa tốt nếu vật thể nhỏ đến rất nhỏ YOLO khó nhận diện những object nằm gần nhau Lý do của những hạn chế này là do chính thuật toán của YOLO mang lại: Bộ phát hiện đối tượng YOLO chia hình ảnh đầu vào thành một mạng lưới SxS trong đó mỗi ô trong lưới chỉ dự đoán một đối tượng duy nhất. Nếu tồn tại nhiều đối tượng nhỏ trong một ô thì YOLO sẽ không thể phát hiện chúng, cuối cùng dẫn đến việc phát hiện đối tượng bị bỏ sót. Do đó, nếu bạn biết tập dữ liệu của mình bao gồm nhiều đối tượng nhỏ được nhóm gần nhau thì bạn không nên sử dụng bộ dò đối tượng YOLO. Về các đối tượng nhỏ, Faster R-CNN có xu hướng hoạt động tốt nhất; tuy nhiên, nó cũng là chậm nhất. SSD cũng có thể được sử dụng ở đây, vấn đề SSD cũng có thể gặp khó khăn với các vật thể nhỏ hơn (nhưng không nhiều như YOLO). SSD cũng thường đem lại sự cân bằng tốt về tốc độ và độ chính xác. Dưới đây là một số kinh nghiệm khi chọn mô hình nhận diện đối tượng cho dự án của bạn: Nếu bạn cần phát hiện các vật thể nhỏ và tốc độ không phải là vấn đề đáng lo ngại, bạn nên dùng Faster R-CNN. Nếu tốc độ là điều tối quan trọng, bạn nên sử dụng YOLO. Nếu bạn cần sự cân bằng hoàn hảo giữa Faster R-CNN và YOLO hãy chọn SSD. Dưới đây là một số hình ảnh so sánh giữa YOLO và các mô hình mạng khác với bộ dữ liệu MS COCO: mAP-50, AP: Đơn vị đo độ chính xác ms: mili giây Và bây giờ chúng ta hãy cùng tìm hiểu xem YOLO hoạt động như thế nào? ","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:2:2","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["AI knowledge"],"content":"C. Cách Thức Hoạt Động Của YOLO Như Thế Nào? Đầu tiên YOLO chụp ảnh đầu vào: Sau đó, chia hình ảnh đầu vào thành các ảnh nhỏ hơn dạng lưới (giả sử là lưới 3 X 3): Phân loại và Localization hình ảnh được áp dụng trên mỗi ô lưới. Sau đó, YOLO dự đoán các hộp giới hạn và xác suất lớp tương ứng của chúng cho các đối tượng (tất nhiên là nếu có). Khá đơn giản, phải không :D? Hãy chia nhỏ từng bước để hiểu chi tiết hơn về những gì chúng ta vừa học. Chúng ta cần chuyển dữ liệu được gắn nhãn vào mô hình để huấn luyện nó. Giả sử chúng ta đã chia hình ảnh thành một lưới kích thước 3 X 3 và có tổng cộng 3 lớp mà chúng ta muốn các đối tượng được phân loại. Giả sử các nhãn học lần lượt là Người đi bộ, Xe ô tô và Xe máy. Vì vậy, đối với mỗi ô lưới, nhãn y sẽ là một vectơ tám chiều: Chú thích: pc xác định xem một đối tượng có trong ô lưới hay không (nó là xác suất) bx , by , bh , bw chỉ định hộp giới hạn (bounding box) nếu có một đối tượng c1 , c2 , c3 đại diện cho các lớp. Vì vậy, nếu đối tượng là một chiếc ô tô, c2 sẽ là 1 và c1 \u0026 c3 sẽ là 0, v.v… Giả sử ta chọn ô lưới đầu tiên từ ví dụ trên: Vì không có đối tượng nào trong ô lưới này, pc sẽ bằng 0 và nhãn y cho ô lưới này sẽ là: ‘?’ ở đây có nghĩa là bx, by, bh, bw, c1 , c2 và c3 chứa những gì không quan trọng vì không có đối tượng nào trong ô lưới. Hãy lấy một ô lưới khác trong đó chúng ta có một chiếc ô tô (c2 = 1): Trước khi chúng ta viết nhãn y cho ô lưới này, điều quan trọng trước tiên là phải hiểu cách YOLO quyết định liệu thực sự có một đối tượng trong ô lưới hay không. Trong hình trên, có hai đối tượng (hai ô tô), vì vậy YOLO sẽ lấy điểm trung tâm của hai đối tượng này và các đối tượng này sẽ được gán vào lưới chứa điểm trung tâm của chúng. Nhãn y cho ô lưới chứa ô tô bên trái sẽ là: Vì có một đối tượng trong ô lưới này, pc sẽ bằng 1. bx , by , bh , bw sẽ được tính liên quan đến ô lưới cụ thể mà chúng ta đang xử lý. Vì ô tô là hạng thứ hai nên c2 = 1 và c1 và c3 = 0. Vì vậy, với mỗi ô lưới trong số 9 ô lưới, chúng ta sẽ có một vectơ đầu ra tám chiều. Đầu ra này sẽ có hình dạng 3 X 3 X 8. Vì vậy, bây giờ chúng ta có một hình ảnh đầu vào và đó là vector mục tiêu tương ứng. Sử dụng ví dụ trên (hình ảnh đầu vào 100 X 100 X 3, đầu ra 3 X 3 X 8), mô hình của chúng ta sẽ được đào tạo như sau: (!): Cho những bạn chưa biết thì giai đoạn nằm giữa từ Input đến Ouput, chính là mạng thần kinh tích chập CNN (Convolutional neural network), nó mô phỏng lại mạng lưới neuron thần kinh não người. Để cho mọi thứ trở nên đơn giản hơn, mình đã giải thích ví dụ trên bằng cách sử dụng lưới 3 X 3, nhưng hầu hết trong các tình huống thực tế, chúng ta sẽ phải sử dụng các lưới lớn hơn (có lẽ là 19 X 19). Ngay cả khi một đối tượng (object) nó trải dài ra nhiều hơn một ô lưới thì nó vẫn sẽ chỉ được gán cho một ô lưới duy nhất mà điểm giữa của nó nằm ở đó. Chúng ta có thể giảm khả năng nhiều đối tượng xuất hiện trong cùng một ô lưới bằng cách tăng số lượng ô nhiều hơn (ví dụ: 19 X 19). Mình rất hi vọng, đọc đến đây thì những bạn chưa từng tiếp cận AI, ML… cũng có thể hiểu đại khái 80-90 %. Cùng nhìn lại một chút, xem mình còn những gì chưa giải đáp không nhỉ? dài thực sự :D. À cái đống bx, by, bh, bw chỉ định hộp giới hạn, hộp giới hạn hay bounding box - cái khung màu đỏ mà các bạn thấy, cái đống hộp xanh, đỏ, tím, vàng này thú vị lắm, cùng giải mã chúng thôi! C.1 Giải Mã Bounding Box Như mình đã đề cập trước đó bx, by, bh và bw có mối liên hệ tới ô lưới mà chúng ta đang xử lý cụ thể là chỉ định bounding box. Cùng tìm hiểu nó qua một ví dụ. Hãy xem xét ô lưới chứa ô tô bên phải trong ảnh: Nhãn y cho ô lưới này sẽ là: pc = 1 vì có một đối tượng trong lưới này và vì nó là một chiếc ô tô nên c2 = 1. Bây giờ, chúng ta hãy xem cách quyết định bx , by , bh và bw . Trong YOLO, tọa độ được gán cho tất cả các ô lưới là: bx , by là tọa độ x và y của trung tâm vật thể đối với ô lưới này. Trong trường hợp này, nó sẽ là (khoảng) bx = 0,4 và by = 0,3: bh là tỷ số giữa chiều cao của ô giới hạn (ô màu đỏ trong ví dụ trên) với c","date":"2020-12-07","objectID":"/vi/objectdetectionyolo/:2:3","tags":["AI","Deep Learning","Machine Learning","YOLO","ObjectDetection"],"title":"YOLO Và Các Thuật toán Object Detection","uri":"/vi/objectdetectionyolo/"},{"categories":["Markdown"],"content":"This article shows the basic Markdown syntax and format.","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files. Ghi chú\r\rThis article is a shameful copy of the great Grav original page. If you want to know about the extented Markdown syntax of LoveIt theme, please read extended Markdown syntax page. \r\r Let's face it: Writing content for the Web is tiresome. WYSIWYG editors help alleviate this task, but they generally result in horrible code, or worse yet, ugly web pages. Markdown is a better way to write HTML, without all the complexities and ugliness that usually accompanies it. Some of the key benefits are: Markdown is simple to learn, with minimal extra characters, so it's also quicker to write content. Less chance of errors when writing in Markdown. Produces valid XHTML output. Keeps the content and the visual display separate, so you cannot mess up the look of your site. Write in any text editor or Markdown application you like. Markdown is a joy to use! John Gruber, the author of Markdown, puts it like this: The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters, the single biggest source of inspiration for Markdown’s syntax is the format of plain text email. – John Gruber Without further delay, let us go over the main elements of Markdown and what the resulting HTML looks like! Mẹo\r\r Bookmark this page for easy future reference!\r\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:0:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"1 Headings Headings from h2 through h6 are constructed with a # for each level: ## h2 Heading\r### h3 Heading\r#### h4 Heading\r##### h5 Heading\r###### h6 Heading\r The HTML looks like this: \u003ch2\u003eh2 Heading\u003c/h2\u003e\r\u003ch3\u003eh3 Heading\u003c/h3\u003e\r\u003ch4\u003eh4 Heading\u003c/h4\u003e\r\u003ch5\u003eh5 Heading\u003c/h5\u003e\r\u003ch6\u003eh6 Heading\u003c/h6\u003e\r Heading IDs\r\rTo add a custom heading ID, enclose the custom ID in curly braces on the same line as the heading: ### A Great Heading {#custom-id}\r The HTML looks like this: \u003ch3 id=\"custom-id\"\u003eA Great Heading\u003c/h3\u003e\r \r\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:1:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"2 Comments Comments should be HTML compatible. \u003c!--This is a comment\r--\u003e\r Comment below should NOT be seen: ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:2:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"3 Horizontal Rules The HTML \u003chr\u003e element is for creating a “thematic break” between paragraph-level elements. In Markdown, you can create a \u003chr\u003e with any of the following: ___: three consecutive underscores ---: three consecutive dashes ***: three consecutive asterisks The rendered output looks like this: ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:3:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"4 Body Copy Body copy written as normal, plain text will be wrapped with \u003cp\u003e\u003c/p\u003e tags in the rendered HTML. So this body copy: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri,\ranimal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex,\rsoluta officiis concludaturque ei qui, vide sensibus vim ad.\r The HTML looks like this: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e\r A line break can be done with one blank line. ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:4:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"5 Inline HTML If you need a certain HTML tag (with a class) you can simply use HTML: Paragraph in Markdown.\r\u003cdiv class=\"class\"\u003e\rThis is \u003cb\u003eHTML\u003c/b\u003e\r\u003c/div\u003e\rParagraph in Markdown.\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:5:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"6 Emphasis ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:6:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Bold For emphasizing a snippet of text with a heavier font-weight. The following snippet of text is rendered as bold text. **rendered as bold text**\r__rendered as bold text__\r The HTML looks like this: \u003cstrong\u003erendered as bold text\u003c/strong\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:6:1","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Italics For emphasizing a snippet of text with italics. The following snippet of text is rendered as italicized text. *rendered as italicized text*\r_rendered as italicized text_\r The HTML looks like this: \u003cem\u003erendered as italicized text\u003c/em\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:6:2","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Strikethrough In GFMGitHub flavored Markdown you can do strikethroughs. ~~Strike through this text.~~\r The rendered output looks like this: Strike through this text. The HTML looks like this: \u003cdel\u003eStrike through this text.\u003c/del\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:6:3","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Combination Bold, italics, and strikethrough can be used in combination. ***bold and italics***\r~~**strikethrough and bold**~~\r~~*strikethrough and italics*~~\r~~***bold, italics and strikethrough***~~\r The rendered output looks like this: bold and italics strikethrough and bold strikethrough and italics bold, italics and strikethrough The HTML looks like this: \u003cem\u003e\u003cstrong\u003ebold and italics\u003c/strong\u003e\u003c/em\u003e\r\u003cdel\u003e\u003cstrong\u003estrikethrough and bold\u003c/strong\u003e\u003c/del\u003e\r\u003cdel\u003e\u003cem\u003estrikethrough and italics\u003c/em\u003e\u003c/del\u003e\r\u003cdel\u003e\u003cem\u003e\u003cstrong\u003ebold, italics and strikethrough\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:6:4","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"7 Blockquotes For quoting blocks of content from another source within your document. Add \u003e before any text you want to quote: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\r The rendered output looks like this: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The HTML looks like this: \u003cblockquote\u003e\r\u003cp\u003e\r\u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\r\u003c/p\u003e\r\u003c/blockquote\u003e\r Blockquotes can also be nested: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue.\rNunc augue augue, aliquam non hendrerit ac, commodo vel nisi.\r\u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor\rodio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam.\r The rendered output looks like this: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:7:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"8 Lists ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:8:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Unordered A list of items in which the order of the items does not explicitly matter. You may use any of the following symbols to denote bullets for each list item: * valid bullet\r- valid bullet\r+ valid bullet\r For example: * Lorem ipsum dolor sit amet\r* Consectetur adipiscing elit\r* Integer molestie lorem at massa\r* Facilisis in pretium nisl aliquet\r* Nulla volutpat aliquam velit\r* Phasellus iaculis neque\r* Purus sodales ultricies\r* Vestibulum laoreet porttitor sem\r* Ac tristique libero volutpat at\r* Faucibus porta lacus fringilla vel\r* Aenean sit amet erat nunc\r* Eget porttitor lorem\r The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003cul\u003e\r\u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e\r\u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e\r\u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e\r\u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e\r\u003cli\u003eNulla volutpat aliquam velit\r\u003cul\u003e\r\u003cli\u003ePhasellus iaculis neque\u003c/li\u003e\r\u003cli\u003ePurus sodales ultricies\u003c/li\u003e\r\u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e\r\u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e\r\u003c/ul\u003e\r\u003c/li\u003e\r\u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e\r\u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e\r\u003cli\u003eEget porttitor lorem\u003c/li\u003e\r\u003c/ul\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:8:1","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Ordered A list of items in which the order of items does explicitly matter. 1. Lorem ipsum dolor sit amet\r2. Consectetur adipiscing elit\r3. Integer molestie lorem at massa\r4. Facilisis in pretium nisl aliquet\r5. Nulla volutpat aliquam velit\r6. Faucibus porta lacus fringilla vel\r7. Aenean sit amet erat nunc\r8. Eget porttitor lorem\r The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003col\u003e\r\u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e\r\u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e\r\u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e\r\u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e\r\u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e\r\u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e\r\u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e\r\u003cli\u003eEget porttitor lorem\u003c/li\u003e\r\u003c/ol\u003e\r Mẹo\r\rIf you just use 1. for each number, Markdown will automatically number each item. For example: 1. Lorem ipsum dolor sit amet\r1. Consectetur adipiscing elit\r1. Integer molestie lorem at massa\r1. Facilisis in pretium nisl aliquet\r1. Nulla volutpat aliquam velit\r1. Faucibus porta lacus fringilla vel\r1. Aenean sit amet erat nunc\r1. Eget porttitor lorem\r The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:8:2","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Task Lists Task lists allow you to create a list of items with checkboxes. To create a task list, add dashes (-) and brackets with a space ([ ]) before task list items. To select a checkbox, add an x in between the brackets ([x]). - [x] Write the press release\r- [ ] Update the website\r- [ ] Contact the media\r The rendered output looks like this: Write the press release Update the website Contact the media ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:8:3","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"9 Code ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:9:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Inline Code Wrap inline snippets of code with `. In this example, `\u003csection\u003e\u003c/section\u003e` should be wrapped as **code**.\r The rendered output looks like this: In this example, \u003csection\u003e\u003c/section\u003e should be wrapped as code. The HTML looks like this: \u003cp\u003e\rIn this example, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e should be wrapped with \u003cstrong\u003ecode\u003c/strong\u003e.\r\u003c/p\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:9:1","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Indented Code Or indent several lines of code by at least four spaces, as in: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r The rendered output looks like this: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r The HTML looks like this: \u003cpre\u003e\r\u003ccode\u003e\r// Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r\u003c/code\u003e\r\u003c/pre\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:9:2","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Block Fenced Code Use “fences” ``` to block in multiple lines of code with a language attribute. ```markdown\rSample text here...\r``` The HTML looks like this: \u003cpre language-html\u003e\r\u003ccode\u003eSample text here...\u003c/code\u003e\r\u003c/pre\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:9:3","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Syntax Highlighting GFMGitHub Flavored Markdown also supports syntax highlighting. To activate it, simply add the file extension of the language you want to use directly after the first code “fence”, ```js, and syntax highlighting will automatically be applied in the rendered HTML. For example, to apply syntax highlighting to JavaScript code: ```js\rgrunt.initConfig({\rassemble: {\roptions: {\rassets: 'docs/assets',\rdata: 'src/data/*.{json,yml}',\rhelpers: 'src/custom-helpers.js',\rpartials: ['src/partials/**/*.{hbs,md}']\r},\rpages: {\roptions: {\rlayout: 'default.hbs'\r},\rfiles: {\r'./': ['src/templates/pages/index.hbs']\r}\r}\r}\r};\r``` The rendered output looks like this: grunt.initConfig({\rassemble: {\roptions: {\rassets: 'docs/assets',\rdata: 'src/data/*.{json,yml}',\rhelpers: 'src/custom-helpers.js',\rpartials: ['src/partials/**/*.{hbs,md}']\r},\rpages: {\roptions: {\rlayout: 'default.hbs'\r},\rfiles: {\r'./': ['src/templates/pages/index.hbs']\r}\r}\r}\r};\r Ghi chú\r\rSyntax highlighting page in Hugo Docs introduces more about syntax highlighting, including highlight shortcode.\r\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:9:4","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"10 Tables Tables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned. | Option | Description |\r| ------ | ----------- |\r| data | path to data files to supply the data that will be passed into templates. |\r| engine | engine to be used for processing templates. Handlebars is the default. |\r| ext | extension to be used for dest files. |\r The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. The HTML looks like this: \u003ctable\u003e\r\u003cthead\u003e\r\u003ctr\u003e\r\u003cth\u003eOption\u003c/th\u003e\r\u003cth\u003eDescription\u003c/th\u003e\r\u003c/tr\u003e\r\u003c/thead\u003e\r\u003ctbody\u003e\r\u003ctr\u003e\r\u003ctd\u003edata\u003c/td\u003e\r\u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e\r\u003c/tr\u003e\r\u003ctr\u003e\r\u003ctd\u003eengine\u003c/td\u003e\r\u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e\r\u003c/tr\u003e\r\u003ctr\u003e\r\u003ctd\u003eext\u003c/td\u003e\r\u003ctd\u003eextension to be used for dest files.\u003c/td\u003e\r\u003c/tr\u003e\r\u003c/tbody\u003e\r\u003c/table\u003e\r Right or center aligned text\r\rAdding a colon on the right side of the dashes below any heading will right align text for that column. Adding colons on both sides of the dashes below any heading will center align text for that column. | Option | Description |\r|:------:| -----------:|\r| data | path to data files to supply the data that will be passed into templates. |\r| engine | engine to be used for processing templates. Handlebars is the default. |\r| ext | extension to be used for dest files. |\r The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:10:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"11 Links ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:11:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Basic Link \u003chttps://assemble.io\u003e\r\u003ccontact@revolunet.com\u003e\r[Assemble](https://assemble.io)\r The rendered output looks like this (hover over the link, there is no tooltip): https://assemble.io contact@revolunet.com Assemble The HTML looks like this: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e\r\u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e\r\u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:11:1","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Add a Title [Upstage](https://github.com/upstage/ \"Visit Upstage!\")\r The rendered output looks like this (hover over the link, there should be a tooltip): Upstage The HTML looks like this: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:11:2","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"Named Anchors Named anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters: ## Table of Contents\r * [Chapter 1](#chapter-1)\r* [Chapter 2](#chapter-2)\r* [Chapter 3](#chapter-3)\r will jump to these sections: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e\rContent for chapter one.\r## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e\rContent for chapter one.\r## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e\rContent for chapter one.\r Ghi chú\r\rThe specific placement of the anchor tag seems to be arbitrary. They are placed inline here since it seems to be unobtrusive, and it works.\r\r ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:11:3","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"12 Footnotes Footnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ([^1]). Identifiers can be numbers or words, but they can’t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself — in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ([^1]: My footnote.). You don’t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. This is a digital footnote[^1].\rThis is a footnote with \"label\"[^label]\r[^1]: This is a digital footnote\r[^label]: This is a footnote with \"label\"\r This is a digital footnote1. This is a footnote with “label”2 ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:12:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["Markdown"],"content":"13 Images Images have a similar syntax to links but include a preceding exclamation point. ![Minion](https://octodex.github.com/images/minion.png)\r or: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\")\r The StormtroopocatAlt text \"\rThe Stormtroopocat\r Like links, images also have a footnote style syntax: ![Alt text][id]\r The DojocatAlt text \"\rThe Dojocat\r With a reference later in the document defining the URL location: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\"\r Mẹo\r\rLoveIt theme has special shortcode for image, which provides more features.\r\r This is a digital footnote ↩︎ This is a footnote with “label” ↩︎ ","date":"2020-09-27","objectID":"/vi/basicmarkdownsyntax/:13:0","tags":["Markdown","HTML"],"title":"Basic Markdown Syntax","uri":"/vi/basicmarkdownsyntax/"},{"categories":["AI Project"],"content":"Ứng dụng phân loại các giống chó, mèo","date":"2020-11-02","objectID":"/vi/classification/","tags":["AI","Deep Learning","Machine Learning","Pytorch","Classification"],"title":"Ứng Dụng Phân Loại Các Giống Chó Mèo","uri":"/vi/classification/"},{"categories":["AI Project"],"content":"BÀI TOÁN PHÂN LỚP TRONG MACHINE LEARNING - ỨNG DỤNG NHẬN DIỆN CÁC GIỐNG CHÓ, MÈO Bài toán phân lớp (classification) là một trong những bài toán lớn trong lĩnh vực Machine Learnig (ML). Classification là quá trình phân lớp một đối tượng dữ liệu vào một hay nhiều lớp đã cho trước nhờ một mô hình phân lớp (classification model). Mô hình này được xây dựng dựa trên một tập dữ liệu được xây dựng trước đó (hay còn gọi là tập huấn luyện). Quá trình phân lớp là quá trình gán nhãn cho đối tượng dữ liệu. Có nhiều bài toán phân lớp dữ liệu như phân lớp nhị phân (binary), phân lớp đa lớp (multiclass),…: Bài toán phân lớp nhị phân là bài toán gắn nhãn dữ liệu cho đối tượng vào một trong hai lớp khác nhau dựa vào việc dữ liệu dó có hay không các đặc trưng (feature) của bộ phân lớp. Bài toán phân lớp đa lớp là quá trình phân lớp dữ liệu với số lượng lớp lớn hơn hai. Như vậy với từng dữ liệu chúng ta phải xem xét và phân lớp chúng vào những lớp khác nhau chứ không phải là hai lớp như bài toán phân lớp nhị phân. Và thực chất bài toán phân lớp nhị phân là một bài toán đặt biệt của phân lớp đa lớp. Ứng dụng của bài toán này được sử dụng rất nhiều và rộng rãi trong thực tế ví dụ như bài toán nhận dạng khuôn mặt, nhận diện giọng nói, phát hiện email spam… Và đối với các bài toán phân lớp dữ liệu chúng ta sử dụng các thuật toán học có giám sát (supervised learning) để xây dựng mô hình cho bài toán này. Sau đây mình sẽ hướng dẫn các bạn cách xây dựng một project “Nhận diện, phân loại các giống chó mèo” từ A-Z sử dụng bộ dữ liệu thực tế. Bài toán mình giới thiệu ở đây thuộc dạng phân lớp đa lớp (multi classification) sử dụng Farmework pytorch, ngôn ngữ python và tkinter để tạo giao diện cho ứng dụng. Okay, bắt đầu thôi nhỉ :D ","date":"2020-11-02","objectID":"/vi/classification/:1:0","tags":["AI","Deep Learning","Machine Learning","Pytorch","Classification"],"title":"Ứng Dụng Phân Loại Các Giống Chó Mèo","uri":"/vi/classification/"},{"categories":["AI Project"],"content":"1. Chuẩn bị tập dữ liệu huấn luyện Bộ dữ liệu mình sử dụng để phân loại giống chó, mèo các bạn có thể tải về tại đây : Pets Dataset Tập dữ liệu gồm 37 loại vật nuôi và khoảng 200 ảnh cho mỗi loại. Sau khi tải dataset về ta tạo một folder data chia lại các thư mục như sau: Trong thư mục train và val, sẽ chứa các thư mục con có tên các loài và ảnh của chúng: Mình chia tập dữ liệu thành 2 phần : training và validation để phục vụ cho mục đích training và kiểm tra độ chính xác. Đầu tiên, khai báo các thư viện sử dụng: import glob\rimport os.path as osp\rimport random\rimport numpy as np\rimport json\rfrom PIL import Image\rimport matplotlib.pyplot as plt\r# %matplotlib inline\r import torch\rimport torch.nn as nn\rimport torch.optim as optim\rimport torch.utils.data as data\rimport torchvision\rfrom torchvision import models, transforms\rfrom tqdm import tqdm\rimport argparse tạo một class ImageTransform, nó sẽ làm nhiệm vụ tiền xử lý các bức ảnh như resize, flipflop, rotate, …. về dạng tiêu chuẩn: ## imagetransform\r class ImageTransform():\rdef __init__(self, resize, mean, std):\rself.data_transform = {\r'train': transforms.Compose([\rtransforms.RandomResizedCrop(resize, scale=(0.5,1.0)),\rtransforms.RandomHorizontalFlip(),\rtransforms.ToTensor(),\rtransforms.Normalize(mean, std)\r]),\r'val': transforms.Compose([\rtransforms.Resize(resize),\rtransforms.CenterCrop(resize),\rtransforms.ToTensor(),\rtransforms.Normalize(mean, std)\r]),\r'test': transforms.Compose([\rtransforms.Resize(resize),\rtransforms.ToTensor(),\rtransforms.Normalize(mean, std)\r]),\r}\rdef __call__(self, img, phase='train'):\rreturn self.data_transform[phase](img)\r Tiếp theo, viết hàm make_data_path_list để tạo một list chứa đường dẫn của ảnh. ## datapath\r def make_datapath_list(phase=\"train\"):\rrootpath = \"./data/\"\rtarget_path = osp.join(rootpath+phase+\"/*/*.jpg\")\rpath_list = []\rfor path in glob.glob(target_path):\rpath_list.append(path)\rreturn path_list\r Cuối cùng tạo class MyDataset, nó sẽ lấy ảnh bằng make_data_path_list ,trả về ảnh đã được qua tiền xử lý bởi ImageTransform và nhãn (label) mà chúng ta sẽ gán vào ảnh: ## dataset\r class MyDataset(data.Dataset):\rdef __init__(self, file_list, transform=None, phase=\"train\"):\rself.file_list = file_list\rself.transform = transform\rself.phase = phase\rdef __len__(self):\rreturn len(self.file_list)\rdef __getitem__(self, idx):\rimg_path = self.file_list[idx]\rimg = Image.open(img_path).convert('RGB')\rimg_transformed = self.transform(img, self.phase)\rif self.phase == \"train\":\rlabel = img_path.split('\\\\')[1]\r# print(label)\r elif self.phase == \"val\":\rlabel = img_path.split(\"\\\\\")[1]\r# print(label)\r if label == \"Abyssinian\":\rlabel = 0\relif label == \"american_bulldog\":\rlabel = 1\relif label == \"american_pitbull\":\rlabel = 2\relif label == \"basset_hound\":\rlabel = 3\relif label == \"beagle\":\rlabel = 4\relif label == \"Bengal\":\rlabel = 5\relif label == \"Birman\":\rlabel = 6\relif label == \"Bombay\":\rlabel = 7\relif label == \"Boxer\":\rlabel = 8\relif label == \"British_Shorthair\":\rlabel = 9\relif label == \"Chihuahua\":\rlabel = 10\relif label == \"Egyptian_Mau\":\rlabel = 11\relif label == \"English_Cocker_Spaniel\":\rlabel = 12\relif label == \"English_Setter\":\rlabel = 13\relif label == \"German_Shorthaired\":\rlabel = 14\relif label == \"Great_Pyrenees\":\rlabel = 15\relif label == \"Havanese\":\rlabel = 16\relif label == \"Japanese_Chin\":\rlabel = 17\relif label == \"Keeshond\":\rlabel = 18\relif label == \"Leonberger\":\rlabel = 19\relif label == \"Main_Coon\":\rlabel = 20\relif label == \"Miniature_Pinscher\":\rlabel = 21\relif label == \"Newfoundland\":\rlabel = 22\relif label == \"Persian\":\rlabel = 23\relif label == \"Pomeranian\":\rlabel = 24\relif label == \"Pug\":\rlabel = 25\relif label == \"Ragdoll\":\rlabel = 26\relif label == \"Russian_Blue\":\rlabel = 27\relif label == \"Saint_Bernard\":\rlabel = 28\relif label == \"Samoyed\":\rlabel = 29\relif label == \"Scottish_Terrier\":\rlabel = 30\relif label == \"Shiba_Inu\":\rlabel = 31\relif label == \"Siamese\":\rlabel = 32\relif label == \"Sphynx\":\rlabel = 33\relif label == \"Staffordshire_Bull_Terrier\":\rlabel = 34\r","date":"2020-11-02","objectID":"/vi/classification/:1:1","tags":["AI","Deep Learning","Machine Learning","Pytorch","Classification"],"title":"Ứng Dụng Phân Loại Các Giống Chó Mèo","uri":"/vi/classification/"},{"categories":["AI Project"],"content":"2. Xây dựng mô hình phân lớp, tạo network Xây dựng mô hình phân lớp (Classifier Model) hay còn gọi là mô hình huấn luyện, thông thường để xây dựng mô hình phân lớp cho bài toán này chúng ta thường sử dụng các thuật toán học có giám sát (supervised learning) như KNN, Neural network, SVM, Decision Tree, Navie Bayers… Ở đây mình sử dụng mạng VGG16, một mô hình đã được huấn luyện sẵn và sử dụng kỹ thuật finetunning để transform lại hàm linear cho hợp với bài toán đang sử dụng: ## network\r use_pretrained = True\rnet = models.vgg16(pretrained=use_pretrained)\rnet.classifier[6] = nn.Linear(in_features=4096, out_features=37)\rprint(net)\rnet = net.train()\r Định nghĩa hàm Loss và thiết lập Optomizer: ## lossfunction\r criterior = nn.CrossEntropyLoss()\rparams_to_update = []\rupdate_params_name = [\"classifier.6.weight\", \"classifier.6.bias\"]\rfor name, param in net.named_parameters():\rif name in update_params_name:\rparam.requires_grad = True\rparams_to_update.append(param)\rprint(name)\relse:\rparam.requires_grad = False\roptimizer = optim.SGD(params=params_to_update, lr=0.001, momentum=0.9)\r ","date":"2020-11-02","objectID":"/vi/classification/:1:2","tags":["AI","Deep Learning","Machine Learning","Pytorch","Classification"],"title":"Ứng Dụng Phân Loại Các Giống Chó Mèo","uri":"/vi/classification/"},{"categories":["AI Project"],"content":"3. Training Sau khi đã tìm được mô hình phân lớp ở bước 2, thì ở đây chúng ta bắt đầu quá trình huấn luyện, đánh giá mô hình bằng cách đánh giá mức độ lỗi của dữ liệu testing và dữ liệu training thông qua mô hình tìm được. Nếu không đạt được kết quả mong muốn thì phải thay đổi các tham số (turning parameter) của các thuật toán học để tìm ra các mô hình tốt hơn và kiểm tra, đánh giá lại mô hình phân lớp. Và cuối cùng chọn ra mô hình phân lớp tốt nhất cho bài toán của chúng ta. dưới đây là code cho phần training: def train_model(net, dataloader_dict, criterior, optimizer, num_epochs):\rfor epoch in range(num_epochs):\rprint(\"Epoch {}/{}\".format(epoch, num_epochs))\rfor phase in [\"train\", \"val\"]:\rif phase == \"train\":\rnet.train()\relse:\rnet.eval()\repoch_loss = 0.0\repoch_corrects = 0\rif (epoch == 0) and (phase == \"train\"):\rcontinue\rfor inputs, labels in tqdm(dataloader_dict[phase]):\roptimizer.zero_grad()\rwith torch.set_grad_enabled(phase == \"train\"):\routputs = net(inputs)\rloss = criterior(outputs, labels)\r_, preds = torch.max(outputs, 1)\rif phase == \"train\":\rloss.backward()\roptimizer.step()\repoch_loss += loss.item()*inputs.size(0)\repoch_corrects += torch.sum(preds==labels.data)\repoch_loss = epoch_loss / len(dataloader_dict[phase].dataset)\repoch_accuracy = epoch_corrects.double() / len(dataloader_dict[phase].dataset)\rprint(\"{} Loss: {:.4f} Acc: {:.4f}\".format(phase, epoch_loss, epoch_accuracy))\rnum_epochs = 2\rtrain_model(net, dataloader_dict, criterior, optimizer, num_epochs)\r Sau quá trình huấn luyện độ chính xác đạt được khoảng tầm 90%, không cao nhưng mình khá hài lòng với kết quả này với bộ dữ liệu không nhiều ở trên. Tạo giao diện, và dưới đây là thành quả: ","date":"2020-11-02","objectID":"/vi/classification/:1:3","tags":["AI","Deep Learning","Machine Learning","Pytorch","Classification"],"title":"Ứng Dụng Phân Loại Các Giống Chó Mèo","uri":"/vi/classification/"},{"categories":null,"content":"Giới Thiệu Cách đây không lâu, có một bạn mới nhắn hỏi mình tạo sao dạo này không còn viết truyện ngắn đăng lên nữa. chợt nhớ ra là trước mình viết rất nhiều, nhưng chỉ một số ít được đăng lên instagram, lý do chính là vì giới hạn số từ. Nên nảy ra ý tưởng là sao không làm một website dưới dạng blog cho chuyên nghiệp hơn, vừa để hệ thống kiến thức IT, vừa để chia sẻ những mẩu chuyện ngắn tự viết. ","date":"2019-08-02","objectID":"/vi/about/:0:1","tags":null,"title":"Về Tôi","uri":"/vi/about/"}]